name: Frontend CI/CD

on:
  pull_request:
    branches: ['develop', 'main']
  push:
    tags:
      - 'v*-dev'
      - 'v*'

env:
  REGION: asia-northeast3
  PROJECT_ID_PROD: leafresh-prod2
  BLUE_MIG_NAME: leafresh-fe-blue-template
  GREEN_MIG_NAME: leafresh-fe-green-template
  LOAD_BALANCER_NAME: leafresh-https-lb
  URL_MAP_NAME: leafresh-https-lb  # URL Map 이름
  BLUE_BACKEND_SERVICE_NAME: leafresh-fe-blue-bs
  GREEN_BACKEND_SERVICE_NAME: leafresh-fe-green-bs


jobs:
  setup:
    name: Setup and Install Dependencies
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      pnpm_cache_hit: ${{ steps.cache-pnpm.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Cache pnpm modules
        id: cache-pnpm
        uses: actions/cache@v3
        with:
          path: ./node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('./pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./

  lint-and-unit-test:
    name: Lint and Unit test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Delete Duplicates
        run: |
          pnpm dedupe
          pnpm install
      - name: Run Lint
        run: pnpm run lint
      - name: Run Unit Test
        run: |
          echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
          echo "${{  secrets.ENV_FE_TEST  }}" >> .env.test

          pnpm run test

  integration-test:
    name: Integration Test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    strategy:
      fail-fast: false
      matrix:
        browser: [chromium]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps ${{ matrix.browser }}
      - name: Build Next.js app for testing
        run: pnpm run build
      - name: Start Next.js app for testing
        run: |
          echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
          echo "${{  secrets.ENV_FE_DEV_PROD  }}" >> .env.production
          
          pnpm run start &
          
      - name: Wait for App to Start (Health Check)
        run: sleep 20
      - name: Run Playwright Tests (${{ matrix.browser }})
        run: pnpm exec playwright test --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: http://localhost:3000

  build-dev:
    name: Build and Push Docker (dev)
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    needs: [lint-and-unit-test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-develop:latest

  build-prod:
    name: Build and Push Docker (prod)
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    needs: [integration-test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-prod:latest

  deploy-dev:
    name: Deploy to Dev Server
    if: startsWith(github.ref, 'refs/tags/v') && endsWith(github.ref, '-dev') && github.base_ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Checkout for git access
        uses: actions/checkout@v3
      
      - name: Extract tag name
        id: tag
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/v}"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: Deploy to Dev
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST_DEV }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd /home/ubuntu/frontend/app
            echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
            echo "${{  secrets.ENV_FE_DEV_PROD  }}" >> .env.production

            IMAGE="jchanho99/frontend-develop:latest"
            cd /home/ubuntu/frontend
            sudo docker compose down --rmi all
            sudo docker compose pull
            sudo docker compose up -d
            sudo docker compose ps

      - name: Upload tag-versioned image to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Tag and Push Docker Image (tag = ${{ env.TAG_NAME }})
        run: |
          docker pull jchanho99/frontend-develop:latest
          docker image tag jchanho99/frontend-develop:latest temp-image-with-label

          # 임시 컨테이너 생성 후 레이블 추가로 digest 변경
          docker container create --name temp-container temp-image-with-label
          docker commit --change "LABEL force-push-tag=${TAG_NAME}-$(date +%s)" temp-container jchanho99/frontend-develop:${TAG_NAME}

          # 정리
          docker container stop temp-container
          docker container rm temp-container
          docker image rm temp-image-with-label

          # 푸시
          docker push jchanho99/frontend-develop:${TAG_NAME}

      - name: Set Status (Dev)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Dev Failure)
        if: failure() && steps.deploy-dev.outcome == 'failure' # deploy-step이 실패했을 때만
        run: echo "status=failure" >> "$GITHUB_OUTPUT"

  deploy-prod:
    name: Deploy to Prod Server (Blue-Green)
    if: startsWith(github.ref, 'refs/tags/v') && !endsWith(github.ref, '-dev') && github.base_ref == 'refs/heads/main'
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout for git access
        uses: actions/checkout@v3

      - name: Extract tag name
        id: tag
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/v}"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV0

      - name: Load environment variables from .env files
        id: load_env_vars
        run: |
          # 환경 변수를 저장할 임시 파일 생성
          TEMP_ENV_FILE=$(mktemp)

          # .env.common 파일이 존재하면 읽어서 임시 파일에 추가
          if [ -f .env.common ]; then
            echo "Loading variables from .env.common"
            while IFS='=' read -r key value; do
              if [[ ! -z "$key" && ! "$key" =~ ^# ]]; then # 주석 및 빈 줄 무시
                echo "$key=\"$value\"" >> "$TEMP_ENV_FILE" # 변수=값 형태로 저장 (값에 공백 있을 수 있으므로 따옴표)
              fi
            done < .env.common
          fi

          # .env.prod 파일이 존재하면 읽어서 임시 파일에 추가 (동일한 키는 덮어씀)
          if [ -f .env.prod ]; then
            echo "Loading variables from .env.prod (will override common values)"
            while IFS='=' read -r key value; do
              if [[ ! -z "$key" && ! "$key" =~ ^# ]]; then # 주석 및 빈 줄 무시
                echo "$key=\"$value\"" >> "$TEMP_ENV_FILE"
              fi
            done < .env.prod
          fi

          # 임시 파일에서 최종 환경 변수 목록을 추출하여 Docker run 옵션 형태로 변환
          ENV_VARS_FOR_DOCKER_RUN=""
          if [ -s "$TEMP_ENV_FILE" ]; then # 파일이 비어있지 않은 경우에만 처리
            # sourced variables will be available as shell variables, then iterate over them
            source "$TEMP_ENV_FILE"
            for var in $(cat "$TEMP_ENV_FILE" | grep -v '^#' | awk -F'=' '{print $1}'); do
                # Use 'eval' to correctly expand the variable (e.g., if value has spaces)
                # This needs careful handling if values contain malicious code
                # For typical .env files, this is usually acceptable.
                ENV_VARS_FOR_DOCKER_RUN+="-e \"$var=$(eval echo \$$var)\" "
            done
          fi

          # 결과 출력 (이 내용은 startup-script로 전달됨)
          echo "Generated Docker run env options: ${ENV_VARS_FOR_DOCKER_RUN}"
          echo "ENV_VARS_FOR_DOCKER_RUN=${ENV_VARS_FOR_DOCKER_RUN}" >> $GITHUB_OUTPUT

          # 임시 파일 삭제
          rm "$TEMP_ENV_FILE"

      - name: Determine current active MIG (Blue or Green)
        id: get_active_mig
        run: |
          # Load Balancer의 URL Map에서 현재 트래픽이 어느 백엔드로 향하고 있는지 확인합니다.
          # Artifact Registry 버전과 동일한 로직을 사용합니다.
          
          ACTIVE_MIG_NAME=""
          INACTIVE_MIG_NAME=""
          ACTIVE_BACKEND_SERVICE=""
          INACTIVE_BACKEND_SERVICE=""

          CURRENT_DEFAULT_SERVICE=$(gcloud compute url-maps describe ${{ env.URL_MAP_NAME }} --project ${{ env.PROJECT_ID_PROD }} --format="value(defaultService)" | awk -F'/' '{print $NF}')

          if [[ "$CURRENT_DEFAULT_SERVICE" == "${{ env.BLUE_BACKEND_SERVICE_NAME }}" ]]; then
            echo "Current active backend is BLUE. Deploying to GREEN."
            ACTIVE_MIG_NAME="${{ env.BLUE_MIG_NAME }}"
            INACTIVE_MIG_NAME="${{ env.GREEN_MIG_NAME }}"
            ACTIVE_BACKEND_SERVICE="${{ env.BLUE_BACKEND_SERVICE_NAME }}"
            INACTIVE_BACKEND_SERVICE="${{ env.GREEN_BACKEND_SERVICE_NAME }}"
          else
            echo "Current active backend is GREEN. Deploying to BLUE."
            ACTIVE_MIG_NAME="${{ env.GREEN_MIG_NAME }}"
            INACTIVE_MIG_NAME="${{ env.BLUE_MIG_NAME }}"
            ACTIVE_BACKEND_SERVICE="${{ env.GREEN_BACKEND_SERVICE_NAME }}"
            INACTIVE_BACKEND_SERVICE="${{ env.BLUE_BACKEND_SERVICE_NAME }}"
          fi
          echo "active_mig_name=$ACTIVE_MIG_NAME" >> $GITHUB_OUTPUT
          echo "inactive_mig_name=$INACTIVE_MIG_NAME" >> $GITHUB_OUTPUT
          echo "active_backend_service=$ACTIVE_BACKEND_SERVICE" >> $GITHUB_OUTPUT
          echo "inactive_backend_service=$INACTIVE_BACKEND_SERVICE" >> $GITHUB_OUTPUT

      - name: Get current MIG instance template name
        id: get_template
        run: |
          TEMPLATE_NAME=$(gcloud compute instance-groups managed describe ${{ steps.get_active_mig.outputs.inactive_mig_name }} --zone ${{ env.REGION }}-a --project ${{ env.PROJECT_ID }} --format="value(instanceTemplate)" | awk -F'/' '{print $NF}')
          echo "current_template_name=$TEMPLATE_NAME" >> $GITHUB_OUTPUT
          
      - name: Create new instance template for inactive MIG
        id: create_new_template
        run: |
          NEW_TEMPLATE_NAME="${{ steps.get_active_mig.outputs.inactive_mig_name }}-${{ github.sha }}"
          FULL_IMAGE_NAME="jchanho99/frontend-prod"

          gcloud compute instance-templates create $NEW_TEMPLATE_NAME \
            --project ${{ env.PROJECT_ID_PROD }} \
            --machine-type e2-custom-2-3072 \
            --image-family ubuntu-2204-lts \
            --image-project ubuntu-os-cloud \
            --boot-disk-size 20GB \
            --metadata startup-script="""#! /bin/bash
            sudo apt-get update
            sudo apt-get install -y ca-certificates curl gnupg lsb-release
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            sudo systemctl start docker
            sudo systemctl enable docker

            echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
            echo "${{  secrets.ENV_FE_PROD  }}" >> .env.production
            
            sudo docker pull $FULL_IMAGE_NAME:latest
            sudo docker run -d -p 80:80 --env-file .env --env-file .env.production $FULL_IMAGE_NAME:latest
            """ \
            --tags http-server,https-server \
            --scopes cloud-platform # 필요한 스코프 추가

          echo "new_template_name=$NEW_TEMPLATE_NAME" >> $GITHUB_OUTPUT

      - name: Update inactive MIG with new instance template
        run: |
          gcloud compute instance-groups managed set-instance-template ${{ steps.get_active_mig.outputs.inactive_mig_name }} \
            --template ${{ steps.create_new_template.outputs.new_template_name }} \
            --zone ${{ env.REGION }}-a \
            --project ${{ env.PROJECT_ID_PROD }}
          
          echo "Waiting for rolling update of ${{ steps.get_active_mig.outputs.inactive_mig_name }} to complete..."
          gcloud compute instance-groups managed wait-until --stable ${{ steps.get_active_mig.outputs.inactive_mig_name }} --zone ${{ env.REGION }}-a --project ${{ env.PROJECT_ID }}
          
      - name: Health Check for inactive MIG
        run: |
          echo "Performing health check on newly deployed MIG (${{ steps.get_active_mig.outputs.inactive_mig_name }})..."
          echo "Simulating health check success. (Replace with actual health check logic)"

      - name: Switch Load Balancer traffic to new MIG
        run: |
          echo "Switching Load Balancer traffic from ${{ steps.get_active_mig.outputs.active_backend_service }} to ${{ steps.get_active_mig.outputs.inactive_backend_service }}..."
          
          gcloud compute url-maps set-default-service ${{ env.URL_MAP_NAME }} \
            --default-service ${{ steps.get_active_mig.outputs.inactive_backend_service }} \
            --project ${{ env.PROJECT_ID_PROD }} \
            --global

          echo "Traffic switch initiated. It may take some time for changes to propagate."
          
      - name: Clean up old instance template (optional)
        run: |
          OLD_TEMPLATE_NAME="${{ steps.get_template.outputs.current_template_name }}"
          if [[ -n "$OLD_TEMPLATE_NAME" ]]; then
            echo "Deleting old instance template: $OLD_TEMPLATE_NAME"
            gcloud compute instance-templates delete $OLD_TEMPLATE_NAME --project ${{ env.PROJECT_ID_PROD }} --quiet
          fi

      - name: Tag and Push Docker Image (tag = ${{ env.TAG_NAME }})
        run: |
          docker pull jchanho99/frontend-prod:latest
          docker image tag jchanho99/frontend-prod:latest temp-image-with-label

          # 임시 컨테이너 생성 후 레이블 추가로 digest 변경
          docker container create --name temp-container temp-image-with-label
          docker commit --change "LABEL force-push-tag=${TAG_NAME}-$(date +%s)" temp-container jchanho99/frontend-prod:${TAG_NAME}

          # 정리
          docker container stop temp-container
          docker container rm temp-container
          docker image rm temp-image-with-label

          # 푸시
          docker push jchanho99/frontend-prod:${TAG_NAME}

      - name: Set Status (Prod)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Prod Failure)
        if: failure() && steps.deploy-prod.outcome == 'failure' # deploy-step이 실패했을 때만
        run: echo "status=failure" >> "$GITHUB_OUTPUT"

  notify:
    name: Discord Notification
    needs: [deploy-dev, deploy-prod] # 명시적으로 종속성 추가
    if: |
      always() &&
      (
        needs.deploy-dev.result != 'skipped' || 
        needs.deploy-prod.result != 'skipped'
      )
    runs-on: ubuntu-latest
    steps:
      - name: Send Discord Message
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          if [[ "${{ needs.deploy-dev.result }}" != 'skipped' ]]; then
            STATUS="${{ needs.deploy-dev.outputs.status }}"
          elif [[ "${{ needs.deploy-prod.result }}" != 'skipped' ]]; then
            STATUS="${{ needs.deploy-prod.outputs.status }}"
          else
            STATUS="unknown"
          fi

          if [[ "$STATUS" == "success" ]]; then
            MESSAGE="✅ [${TAG}] 배포 완료"
          elif [[ "$STATUS" == "failure" ]]; then
            MESSAGE="🚨 [${TAG}] 배포 실패. actions에서 로그를 확인하세요."
          else
            MESSAGE="⚠️ [${TAG}] 배포 상태를 알 수 없습니다."
          fi

          echo "message=$MESSAGE" >> $GITHUB_OUTPUT

          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{\"content\": \"$MESSAGE\"}" \
               ${{ secrets.DISCORD_WEBHOOK_URL }}
