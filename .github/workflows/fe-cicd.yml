name: Frontend CI/CD

on:
  pull_request:
    branches: ['develop', 'main']
  push:
    tags:
      - 'v*-dev'
      - 'v*'

jobs:
  setup:
    name: Setup and Install Dependencies
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      pnpm_cache_hit: ${{ steps.cache-pnpm.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Cache pnpm modules
        id: cache-pnpm
        uses: actions/cache@v3
        with:
          path: ./node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('./pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./

  lint-and-unit-test:
    name: Lint and Unit test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Delete Duplicates
        run: |
          pnpm dedupe
          pnpm install
      - name: Run Lint
        run: pnpm run lint
      - name: Run Unit Test
        run: |
          echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
          echo "${{  secrets.ENV_FE_TEST  }}" >> .env.test
          echo "${{  secrets.ENV_FE_PROD  }}" >> .env.production
          pnpm run test
        env:
          NEXT_PUBLIC_RUNTIME: dev
          NEXT_PUBLIC_GOOGLE_ANALYTICS: 'G-2BKG11WDXZ'

  integration-test:
    name: Integration Test
    needs: setup
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./
    strategy:
      fail-fast: false
      matrix:
        browser: [chromium]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 'lts/*'
      - uses: pnpm/action-setup@v2
        with:
          version: latest
      - name: Use cached pnpm modules
        if: steps.setup.outputs.pnpm_cache_hit == 'true'
        run: echo "Using cached pnpm modules"
      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps ${{ matrix.browser }}
      - name: Build Next.js app for testing
        run: pnpm run build
      - name: Start Next.js app for testing
        run: |
          echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
          echo "${{  secrets.ENV_FE_DEV_PROD  }}" >> .env.production

          pnpm run start &

      - name: Wait for App to Start (Health Check)
        run: sleep 20
      - name: Run Playwright Tests (${{ matrix.browser }})
        run: pnpm exec playwright test --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: http://localhost:3000

  build-dev:
    name: Build and Push Docker (dev)
    if: github.event_name == 'pull_request' && github.base_ref == 'develop'
    needs: [lint-and-unit-test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-develop:latest
          build-args: |
            NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.ENV_FE_ANALYTICS }}
            NEXT_PUBLIC_RUNTIME=${{ secrets.ENV_FE_DEV_PROD }}

  build-prod:
    name: Build and Push Docker (prod)
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    needs: [integration-test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jchanho99/frontend-prod:latest
          build-args: |
            NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.ENV_FE_ANALYTICS }}
            NEXT_PUBLIC_RUNTIME=${{ secrets.ENV_FE_PROD }}

  deploy-dev:
    name: Deploy to Dev Server
    if: startsWith(github.ref, 'refs/tags/v') && endsWith(github.ref, '-dev')
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - name: Checkout for git access
        uses: actions/checkout@v3

      - name: Extract tag name
        id: tag
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: Deploy to Dev
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST_DEV }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd /home/ubuntu/frontend/app
            echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
            echo "${{  secrets.ENV_FE_DEV_PROD  }}" >> .env.production

            IMAGE="jchanho99/frontend-develop:latest"
            cd /home/ubuntu/frontend
            sudo docker compose down --rmi all
            sudo docker compose pull
            sudo docker compose up -d
            sudo docker compose ps

      - name: Upload tag-versioned image to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Tag and Push Docker Image (tag = ${{ env.TAG_NAME }})
        env:
          TAG_NAME: ${{ env.TAG_NAME }}
        run: |
          docker pull jchanho99/frontend-develop:latest
          docker image tag jchanho99/frontend-develop:latest temp-image-with-label

          # ìž„ì‹œ ì»¨í…Œì´ë„ˆ ìƒì„± í›„ ë ˆì´ë¸” ì¶”ê°€ë¡œ digest ë³€ê²½
          docker container create --name temp-container temp-image-with-label
          docker commit --change "LABEL force-push-tag=${TAG_NAME}-$(date +%s)" temp-container jchanho99/frontend-develop:${TAG_NAME}

          # ì •ë¦¬
          docker container stop temp-container
          docker container rm temp-container
          docker image rm temp-image-with-label

          # í‘¸ì‹œ
          docker push jchanho99/frontend-develop:${TAG_NAME}

      - name: Set Status (Dev)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Dev Failure)
        if: failure() && steps.deploy-dev.outcome == 'failure' # deploy-stepì´ ì‹¤íŒ¨í–ˆì„ ë•Œë§Œ
        run: echo "status=failure" >> "$GITHUB_OUTPUT"

  deploy-prod:
    name: Deploy to Prod Server (Blue-Green)
    if: startsWith(github.ref, 'refs/tags/v') && !endsWith(github.ref, '-dev')
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout for git access
        uses: actions/checkout@v3

      - name: Extract commit SHA from tag
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          COMMIT_SHA=$(git rev-list -n 1 "$TAG")
          SHORT_SHA=${COMMIT_SHA:0:7}
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV

      - name: Deploy to Prod
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST_PROD }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # dir ì¶”ê°€ í•„ìš”
            echo "${{  secrets.ENV_FE_ANALYTICS  }}" >> .env
            echo "${{  secrets.ENV_FE_PROD  }}" >> .env.production




            set -e # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¦‰ì‹œ ìŠ¤í¬ë¦½íŠ¸ ì¤‘ë‹¨
            VERSION="${{ github.ref }}"             # ex: refs/tags/v2.0.6
            VERSION="${VERSION#refs/tags/}"         # remove prefix
            IMAGE="jchanho99/frontend-prod:${{ env.VERSION }}"
            HEALTH_CHECK_URL="http://localhost:3001" # í—¬ìŠ¤ ì²´í¬ URL

            echo "ðŸš€ Starting Prod Blue-Green Deployment to host: ${{ secrets.LEAFRESH_PROD_HOST }}"
            echo "ðŸ–¼ï¸ Using image: $IMAGE"

            cd /opt/frontend/
            echo "PWD: $(pwd)"

            echo "ðŸšš Pulling Docker image: $IMAGE"
            sudo docker pull "$IMAGE"

            CURRENT=$(cat /opt/frontend-current 2>/dev/null || echo blue)
            NEXT=$([ "$CURRENT" = "blue" ] && echo green || echo blue)

            echo "ðŸ”µ Current active environment: $CURRENT"
            echo "ðŸŸ¢ Next environment to deploy: $NEXT"

            echo "ðŸš€ Bringing up $NEXT environment (frontend-$NEXT)..."
            # ë§Œì•½ docker-compose.ymlì—ì„œ $NEXTì— í•´ë‹¹í•˜ëŠ” íŠ¹ì • ì„œë¹„ìŠ¤ë¥¼ ì§€ì •í•´ì•¼ í•œë‹¤ë©´,
            # ì˜ˆ: sudo docker compose up -d service-$NEXT
            sudo docker compose up -d # ì´ ëª…ë ¹ì´ frontend-$NEXT ì»¨í…Œì´ë„ˆë¥¼ ì‹œìž‘/ì—…ë°ì´íŠ¸í•´ì•¼ í•¨

            echo "ðŸ©º Performing health check for $NEXT on $HEALTH_CHECK_URL..."
            HEALTH_CHECK_PASSED=false
            for i in {1..60}; do
              if nc -z localhost 3001 2>/dev/null; then
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL")
                if [ "$HTTP_CODE" -eq 200 ]; then
                  CONTENT_STATUS=$(curl -s "$HEALTH_CHECK_URL" | grep "<title>")
                  if [ ! -z "$CONTENT_STATUS" ]; then
                    echo "âœ… Health check passed for $NEXT on attempt $i (HTTP $HTTP_CODE with <title>)."
                    HEALTH_CHECK_PASSED=true
                    break
                  fi
                fi
              fi
              echo "â³ Waiting ($i)..."
              sleep 1
            done

            if [ "$HEALTH_CHECK_PASSED" != "true" ]; then
              echo "âŒ Health check failed for $NEXT environment after 60 attempts."
              echo "ðŸ’£ Rolling back: Attempting to stop and remove $NEXT environment (frontend-$NEXT)..."
              sudo docker stop "frontend-$NEXT" || true
              sudo docker rm "frontend-$NEXT" || true
              exit 1
            fi

            echo "âœ… Health check successful for $NEXT environment."
            echo "ðŸ”„ Switching traffic..."

            echo "ðŸ›‘ Stopping and removing $CURRENT environment (frontend-$CURRENT)..."
            sudo docker stop "frontend-$CURRENT" || true
            sudo docker rm "frontend-$CURRENT" || true

            echo "âš ï¸ Force restarting $NEXT environment as per original script logic (stop, rm, up)..."
            sudo docker stop "frontend-$NEXT" || true
            sudo docker rm "frontend-$NEXT" || true
            sudo docker compose up -d # $NEXT í™˜ê²½ì„ ë‹¤ì‹œ ì‹œìž‘

            echo "$NEXT" > /opt/frontend-current
            echo "ðŸŽ‰ Prod Blue-Green deployment to $NEXT complete. $NEXT is now active."

      - name: Set Status (Prod)
        id: set-status
        if: success()
        run: echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Set Status (Prod Failure)
        if: failure() && steps.deploy-prod.outcome == 'failure' # deploy-stepì´ ì‹¤íŒ¨í–ˆì„ ë•Œë§Œ
        run: echo "status=failure" >> "$GITHUB_OUTPUT"

  notify:
    name: Discord Notification
    needs: [deploy-dev, deploy-prod] # ëª…ì‹œì ìœ¼ë¡œ ì¢…ì†ì„± ì¶”ê°€
    if: |
      always() &&
      (
        needs.deploy-dev.result != 'skipped' || 
        needs.deploy-prod.result != 'skipped'
      )
    runs-on: ubuntu-latest
    steps:
      - name: Send Discord Message
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          if [[ "${{ needs.deploy-dev.result }}" != 'skipped' ]]; then
            STATUS="${{ needs.deploy-dev.outputs.status }}"
          elif [[ "${{ needs.deploy-prod.result }}" != 'skipped' ]]; then
            STATUS="${{ needs.deploy-prod.outputs.status }}"
          else
            STATUS="unknown"
          fi

          if [[ "$STATUS" == "success" ]]; then
            MESSAGE="âœ… [${TAG}] ë°°í¬ ì™„ë£Œ"
          elif [[ "$STATUS" == "failure" ]]; then
            MESSAGE="ðŸš¨ [${TAG}] ë°°í¬ ì‹¤íŒ¨. actionsì—ì„œ ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”."
          else
            MESSAGE="âš ï¸ [${TAG}] ë°°í¬ ìƒíƒœë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
          fi

          echo "message=$MESSAGE" >> $GITHUB_OUTPUT

          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{\"content\": \"$MESSAGE\"}" \
               ${{ secrets.DISCORD_WEBHOOK_URL }}
